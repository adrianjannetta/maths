<div style="border:2px solid #1e5aa8; border-radius:12px; padding:16px; max-width:1100px; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;">
  <h2 style="margin:0 0 8px 0; color:#1e5aa8;">Water Phase Diagram + Heating Curve Explorer</h2>
  <div style="font-size:14px; color:#234; line-height:1.35; margin-bottom:12px;">
    Controls set <b>pressure</b>, <b>starting temperature</b>, and <b>mass</b>. The <b>heating curve</b> shows \(T\) vs heat added.
    The dot on the <b>phase diagram</b> tracks the state as heating progresses.
  </div>

  <div style="display:flex; gap:16px; flex-wrap:wrap; align-items:flex-start;">
    <!-- Controls -->
    <div style="flex:1 1 330px; min-width:320px;">
      <div style="display:grid; grid-template-columns: 150px 1fr; gap:10px 12px; align-items:center;">

        <label for="Pslider"><b>Pressure</b></label>
        <div>
          <input id="Pslider" type="range" min="-5" max="6" step="0.01" value="0" style="width:100%;">
          <div style="display:flex; justify-content:space-between; font-size:12px; color:#456;">
            <span>10⁻⁵ bar</span><span>10⁶ bar</span>
          </div>
          <div style="font-size:12px; color:#567; margin-top:4px;">
            Slider is <b>log₁₀(P/bar)</b>. (So 0 = 1 bar, 3 = 1000 bar, −5 = 10⁻⁵ bar)
          </div>
        </div>

        <label for="Tstart"><b>Start T</b></label>
        <div>
          <input id="Tstart" type="range" min="-150" max="300" step="1" value="-20" style="width:100%;">
          <div style="display:flex; justify-content:space-between; font-size:12px; color:#456;">
            <span>-150°C</span><span>300°C</span>
          </div>
        </div>

        <label for="mass"><b>Mass</b></label>
        <div style="display:flex; gap:8px; align-items:center;">
          <input id="mass" type="number" min="0.05" max="10" step="0.05" value="1" style="width:110px; padding:6px; border:1px solid #ccd; border-radius:8px;">
          <span style="font-size:13px;">kg</span>
        </div>

        <label for="Qslider"><b>Heat added</b></label>
        <div>
          <input id="Qslider" type="range" min="0" max="3500" step="1" value="0" style="width:100%;">
          <div style="display:flex; justify-content:space-between; font-size:12px; color:#456;">
            <span>0</span><span id="QmaxLabel">3500 kJ</span>
          </div>
          <div style="font-size:12px; color:#567; margin-top:4px;">
            This is total heat \(Q\) added to the sample (kJ).
          </div>
        </div>

        <label><b>Quick set</b></label>
        <div style="display:flex; gap:8px; flex-wrap:wrap;">
          <button class="btn" data-preset="sea">1 bar</button>
          <button class="btn" data-preset="mountain">0.7 bar</button>
          <button class="btn" data-preset="pressurecooker">15 bar</button>
          <button class="btn" data-preset="deep">10⁴ bar</button>
          <button class="btn" data-preset="verydeep">10⁶ bar</button>
        </div>
      </div>

      <div style="margin-top:12px; padding:12px; border-radius:12px; background:#f3f8ff; border:1px solid #cfe2ff;">
        <div style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="font-size:13px; color:#345;">P = <b><span id="Pout">1.00</span> bar</b> (<span id="logPout">log₁₀P = 0.00</span>)</div>
          <div style="font-size:13px; color:#345;">Start T = <b><span id="TstartOut">-20</span> °C</b></div>
          <div style="font-size:13px; color:#345;">Q = <b><span id="Qout">0</span> kJ</b></div>
        </div>
        <div style="margin-top:8px; font-size:14px;">
          <b>Current state on heating curve:</b> <span id="stateOut" style="color:#0b4;">Ice warming</span><br>
          <b>Current temperature:</b> <span id="TnowOut">-20.0</span> °C
        </div>
        <div style="margin-top:8px; font-size:13px; color:#234; line-height:1.35;">
          <div><b>Key temperatures at this pressure (approx):</b></div>
          <div>• Melting point \(T_m\) ≈ <b><span id="TmOut">0.0</span> °C</b></div>
          <div>• Boiling point \(T_b\) ≈ <b><span id="TbOut">100.0</span> °C</b></div>
        </div>
      </div>

      <div style="margin-top:10px; font-size:12px; color:#567;">
        Diagram axes: \(T \in [-150,450]^\circ\mathrm{C}\), \(P \in [10^{-5},10^{6}]\) bar. Curves are approximate (teaching model).
      </div>
    </div>

    <!-- Plots -->
    <div style="flex:1 1 700px; min-width:360px; display:grid; gap:12px;">
      <canvas id="phaseCanvas" width="720" height="380" style="width:100%; height:auto; border-radius:12px; border:1px solid #cdd; background:white;"></canvas>
      <canvas id="heatCanvas" width="720" height="360" style="width:100%; height:auto; border-radius:12px; border:1px solid #cdd; background:white;"></canvas>
    </div>
  </div>
</div>

<script>
(() => {
  // ---------- Helpers ----------
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const log10 = (x)=>Math.log(x)/Math.LN10;

  // ---------- Phase-curve approximations (teaching model) ----------
  // Antoine saturation curve for water (blended constants; good for intuition, not precision).
  function Psat_bar(Tc){
    const A1=8.07131, B1=1730.63, C1=233.426; // ~1–100°C
    const A2=8.14019, B2=1810.94, C2=244.485; // ~100–374°C
    let w=0;
    if (Tc<=90) w=0;
    else if (Tc>=110) w=1;
    else w=(Tc-90)/20;
    const logP1 = A1 - (B1/(C1+Tc));
    const logP2 = A2 - (B2/(C2+Tc));
    const logPmmHg = (1-w)*logP1 + w*logP2;
    const Pbar = (Math.pow(10,logPmmHg)/760)*1.01325;
    return clamp(Pbar,1e-12,1e9);
  }

  // Invert Psat_bar(T) by bisection to estimate boiling temperature for a given P.
  function invertPsatForT(Pbar){
    let lo=-150, hi=450;
    for (let i=0;i<55;i++){
      const mid=0.5*(lo+hi);
      const pm=Psat_bar(mid);
      if (pm<Pbar) lo=mid; else hi=mid;
    }
    return 0.5*(lo+hi);
  }

  // Sublimation curve (ice-vapour) – simple fit, anchored around triple point; teaching-only.
  function Psub_bar(Tc){
    const Tk=Tc+273.15;
    const a=6.74, b=-2350;
    const logP=a + b/Tk;
    return clamp(Math.pow(10,logP),1e-12,0.05);
  }

  // Simplified melting line (solid-liquid). Real water is complex at high pressure;
  // this is chosen to show "ice melts under pressure" near 0°C.
  function Tmelt_C(Pbar){
    const k=0.007; // °C/bar (exaggerated for visibility; teaching model)
    return 0 - k*(Pbar-1);
  }

  const TRIPLE={T:0.01,P:0.0061};
  const CRIT={T:374,P:221};

  function phaseOf(Tc,Pbar){
    if (Tc>=CRIT.T && Pbar>=CRIT.P) return "Supercritical fluid";
    if (Tc<TRIPLE.T && Pbar<TRIPLE.P){
      const Psub=Psub_bar(Tc);
      return (Pbar>=Psub) ? "Solid (ice)" : "Vapour";
    }
    const Tm=Tmelt_C(Pbar);
    if (Tc<=Tm && Pbar>=TRIPLE.P) return "Solid (ice)";
    const Ps=Psat_bar(Tc);
    return (Pbar>=Ps) ? "Liquid" : "Vapour";
  }

  // ---------- Heating curve model ----------
  // Constants (kJ/kg/K and kJ/kg)
  const c_ice=2.1, c_liq=4.18, c_steam=2.0;
  const Lf=334, Lv=2256;

  function buildHeatingSegments(Pbar, TstartC, mkg){
    const Tm = Tmelt_C(Pbar);
    const Tb = invertPsatForT(Pbar);
    const normal = (Pbar >= TRIPLE.P);

    const segs = [];
    let Q=0, T=TstartC;
    const push = (Q0,Q1,T0,T1,label)=>segs.push({Q0,Q1,T0,T1,label});

    if (!normal){
      const Ttp = TRIPLE.T;
      if (T < Ttp){
        const dQ = mkg*c_ice*(Ttp - T);
        push(Q,Q+dQ,T,Ttp,"Ice warming");
        Q+=dQ; T=Ttp;
      }
      const dQ2 = mkg*(Lf+Lv)*0.6;
      push(Q,Q+dQ2,Ttp,Ttp,"Sublimation / phase change");
      Q+=dQ2;
      const Tend=250;
      const dQ3 = mkg*c_steam*(Tend - Ttp);
      push(Q,Q+dQ3,Ttp,Tend,"Vapour warming");
      Q+=dQ3;
      return {segs, Tm:Ttp, Tb:Tb, Qmax:Q};
    }

    if (T < Tm){
      const dQ = mkg*c_ice*(Tm - T);
      push(Q,Q+dQ,T,Tm,"Ice warming");
      Q+=dQ; T=Tm;
    }
    if (T <= Tm + 1e-9){
      const dQ = mkg*Lf;
      push(Q,Q+dQ,Tm,Tm,"Melting (latent heat)");
      Q+=dQ; T=Tm;
    }
    if (T < Tb){
      const dQ = mkg*c_liq*(Tb - T);
      push(Q,Q+dQ,T,Tb,"Liquid warming");
      Q+=dQ; T=Tb;
    }
    if (Tb < CRIT.T && Pbar < CRIT.P){
      const dQ = mkg*Lv;
      push(Q,Q+dQ,Tb,Tb,"Boiling (latent heat)");
      Q+=dQ;
    }
    const Tend = (Pbar >= CRIT.P) ? 450 : 350;
    const dQ = mkg*c_steam*(Tend - Tb);
    push(Q,Q+dQ,Tb,Tend,(Pbar >= CRIT.P) ? "Supercritical warming" : "Steam warming");
    Q+=dQ;

    return {segs, Tm, Tb, Qmax:Q};
  }

  function TfromQ(segs, Q){
    for (const s of segs){
      if (Q >= s.Q0 && Q <= s.Q1){
        if (Math.abs(s.T1 - s.T0) < 1e-9) return {T:s.T0, label:s.label};
        const f=(Q-s.Q0)/(s.Q1-s.Q0);
        return {T:s.T0 + f*(s.T1-s.T0), label:s.label};
      }
    }
    const last=segs[segs.length-1];
    return {T:last.T1, label:last.label};
  }

  // ---------- Generic axes drawer ----------
  function drawAxes(ctx, W, H, M, xLabel, yLabel, xTicks, yTicks){
    ctx.clearRect(0,0,W,H);

    // grid
    ctx.save();
    ctx.strokeStyle="#e7eef9";
    ctx.lineWidth=1;
    xTicks.forEach(t=>{
      ctx.beginPath(); ctx.moveTo(t.x, M.t); ctx.lineTo(t.x, H-M.b); ctx.stroke();
    });
    yTicks.forEach(t=>{
      ctx.beginPath(); ctx.moveTo(M.l, t.y); ctx.lineTo(W-M.r, t.y); ctx.stroke();
    });
    ctx.restore();

    // axes
    ctx.save();
    ctx.strokeStyle="#234";
    ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.moveTo(M.l,H-M.b); ctx.lineTo(W-M.r,H-M.b); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(M.l,M.t); ctx.lineTo(M.l,H-M.b); ctx.stroke();
    ctx.restore();

    // tick labels
    ctx.fillStyle="#234";
    ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    xTicks.forEach(t=>{
      ctx.strokeStyle="#234"; ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(t.x,H-M.b); ctx.lineTo(t.x,H-M.b+6); ctx.stroke();
      ctx.fillText(t.label, t.x-14, H-M.b+22);
    });
    yTicks.forEach(t=>{
      ctx.strokeStyle="#234"; ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(M.l-6,t.y); ctx.lineTo(M.l,t.y); ctx.stroke();
      ctx.fillText(t.label, 12, t.y+4);
    });

    // axis labels
    ctx.fillText(xLabel, (M.l+W-M.r)/2 - ctx.measureText(xLabel).width/2, H-18);
    ctx.save();
    ctx.translate(16,(M.t+H-M.b)/2 + ctx.measureText(yLabel).width/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();
  }

  // ---------- Phase diagram ----------
  const phaseCanvas=document.getElementById("phaseCanvas");
  const pctx=phaseCanvas.getContext("2d");
  const pW=phaseCanvas.width, pH=phaseCanvas.height;
  const pM={l:70,r:16,t:18,b:50};

  // UPDATED DOMAINS:
  const Tmin=-150, Tmax=450;
  const lpMin=-5, lpMax=6; // => P from 1e-5 to 1e6 bar

  const xOfT = (T)=>pM.l + (T-Tmin)*(pW-pM.l-pM.r)/(Tmax-Tmin);
  const yOfLP = (lp)=>pH-pM.b - (lp-lpMin)*(pH-pM.t-pM.b)/(lpMax-lpMin);

  function sampleCurve(fnPbar, T0, T1, step){
    const pts=[];
    for (let T=T0; T<=T1+1e-9; T+=step){
      const P=fnPbar(T);
      const lp=log10(P);
      if (!isFinite(lp)) continue;
      pts.push({T, lp});
    }
    return pts;
  }

  function drawPhaseDiagram(Tc, Pbar){
    // ticks
    const xTicks=[];
    for (let T=-150; T<=450; T+=150) xTicks.push({x:xOfT(T), label:String(T)});
    const yTicks=[];
    for (let lp=-5; lp<=6; lp+=1) {
      // show fewer labels (every 2) to reduce clutter
      if (lp%2===0) yTicks.push({y:yOfLP(lp), label:String(lp)});
      else yTicks.push({y:yOfLP(lp), label:""});
    }

    drawAxes(pctx,pW,pH,pM,"Temperature (°C)","log₁₀(P/bar)",xTicks,yTicks);

    // --- Curves (for shading & boundaries) ---
    const subPts = sampleCurve(Psub_bar, Tmin, TRIPLE.T, 1);
    const boilPts = sampleCurve(Psat_bar, TRIPLE.T, Tmax, 1);

    // Melting line: sample in logP space
    const meltPts=[];
    for (let lp=lpMin; lp<=lpMax; lp+=0.03){
      const P=Math.pow(10,lp);
      const Tm=Tmelt_C(P);
      meltPts.push({T:Tm, lp});
    }

    // --- Region shading (simple, clear, teaching-style) ---
    // Vapour: below sublimation (left of triple) + below boiling (right of triple)
    pctx.save();
    pctx.globalAlpha=0.12;
    pctx.fillStyle="#1e5aa8";

    // vapour below sub curve (Tmin -> triple)
    pctx.beginPath();
    pctx.moveTo(xOfT(Tmin), yOfLP(lpMin));
    for (const pt of subPts) pctx.lineTo(xOfT(pt.T), yOfLP(clamp(pt.lp, lpMin, lpMax)));
    pctx.lineTo(xOfT(TRIPLE.T), yOfLP(lpMin));
    pctx.closePath();
    pctx.fill();

    // vapour below boiling curve (triple -> Tmax)
    pctx.beginPath();
    pctx.moveTo(xOfT(TRIPLE.T), yOfLP(lpMin));
    for (const pt of boilPts) pctx.lineTo(xOfT(pt.T), yOfLP(clamp(pt.lp, lpMin, lpMax)));
    pctx.lineTo(xOfT(Tmax), yOfLP(lpMin));
    pctx.closePath();
    pctx.fill();
    pctx.restore();

    // Solid: above sublimation (left side) and left/below melt line at higher pressures (very simplified)
    pctx.save();
    pctx.globalAlpha=0.12;
    pctx.fillStyle="#666";

    // solid above sublimation (Tmin -> triple), up to top of chart
    pctx.beginPath();
    pctx.moveTo(xOfT(Tmin), yOfLP(lpMax));
    pctx.lineTo(xOfT(Tmin), yOfLP(lpMin));
    for (const pt of subPts) pctx.lineTo(xOfT(pt.T), yOfLP(clamp(pt.lp, lpMin, lpMax)));
    pctx.lineTo(xOfT(TRIPLE.T), yOfLP(lpMax));
    pctx.closePath();
    pctx.fill();

    // solid left of melting curve (for lp >= triple-ish): draw a band using melting curve as boundary
    pctx.beginPath();
    // top-left corner
    pctx.moveTo(xOfT(Tmin), yOfLP(lpMax));
    // down left edge
    pctx.lineTo(xOfT(Tmin), yOfLP(lpMin));
    // go along bottom to first melting point's T (roughly)
    // then trace melting curve upwards
    // We'll trace melt curve from low lp to high lp, and close to left edge.
    for (const pt of meltPts){
      const T=clamp(pt.T, Tmin, Tmax);
      const lp=clamp(pt.lp, lpMin, lpMax);
      pctx.lineTo(xOfT(T), yOfLP(lp));
    }
    // close to top-left
    pctx.lineTo(xOfT(Tmin), yOfLP(lpMax));
    pctx.closePath();
    pctx.fill();
    pctx.restore();

    // Liquid: above boiling curve and to the right of melting line (very simplified)
    pctx.save();
    pctx.globalAlpha=0.10;
    pctx.fillStyle="#0b8a3b";

    // liquid above boiling (from triple to min(critical-ish))
    pctx.beginPath();
    pctx.moveTo(xOfT(TRIPLE.T), yOfLP(lpMax));
    for (const pt of boilPts) pctx.lineTo(xOfT(pt.T), yOfLP(clamp(pt.lp, lpMin, lpMax)));
    pctx.lineTo(xOfT(Tmax), yOfLP(lpMax));
    pctx.closePath();
    pctx.fill();
    pctx.restore();

    // Supercritical region shading
    pctx.save();
    pctx.globalAlpha=0.10;
    pctx.fillStyle="#b22";
    const xCrit=xOfT(CRIT.T), yCrit=yOfLP(log10(CRIT.P));
    pctx.beginPath();
    pctx.moveTo(xCrit, yCrit);
    pctx.lineTo(xOfT(Tmax), yCrit);
    pctx.lineTo(xOfT(Tmax), yOfLP(lpMax));
    pctx.lineTo(xCrit, yOfLP(lpMax));
    pctx.closePath();
    pctx.fill();
    pctx.restore();

    // --- Draw boundaries (CLEAR) ---
    function drawCurveFromPts(pts, stroke, width){
      pctx.save();
      pctx.strokeStyle=stroke;
      pctx.lineWidth=width;
      pctx.beginPath();
      let first=true;
      for (const pt of pts){
        const x=xOfT(pt.T), y=yOfLP(clamp(pt.lp, lpMin, lpMax));
        if (first){pctx.moveTo(x,y); first=false;}
        else pctx.lineTo(x,y);
      }
      pctx.stroke();
      pctx.restore();
    }

    // Sublimation boundary
    drawCurveFromPts(subPts, "#444", 3);

    // Boiling/condensation boundary
    drawCurveFromPts(boilPts, "#1e5aa8", 3);

    // Melting boundary (sampled in lp)
    pctx.save();
    pctx.strokeStyle="#2f8f2f";
    pctx.lineWidth=3;
    pctx.beginPath();
    let first=true;
    for (const pt of meltPts){
      const x=xOfT(clamp(pt.T, Tmin, Tmax));
      const y=yOfLP(clamp(pt.lp, lpMin, lpMax));
      if (first){pctx.moveTo(x,y); first=false;}
      else pctx.lineTo(x,y);
    }
    pctx.stroke();
    pctx.restore();

    // Key points
    function keyPoint(pt, label){
      const x=xOfT(pt.T), y=yOfLP(log10(pt.P));
      pctx.fillStyle="#b22";
      pctx.beginPath(); pctx.arc(x,y,4,0,Math.PI*2); pctx.fill();
      pctx.fillStyle="#234";
      pctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      pctx.fillText(label, x+8, y-6);
    }
    keyPoint(TRIPLE,"Triple point");
    keyPoint(CRIT,"Critical point");

    // Region labels (stronger)
    pctx.save();
    pctx.font="bold 15px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    pctx.fillStyle="rgba(30,90,168,0.75)";
    pctx.fillText("VAPOUR", xOfT(240), yOfLP(-2.8));
    pctx.fillStyle="rgba(11,138,59,0.75)";
    pctx.fillText("LIQUID", xOfT(40), yOfLP(1.0));
    pctx.fillStyle="rgba(80,80,80,0.75)";
    pctx.fillText("SOLID", xOfT(-110), yOfLP(2.5));
    pctx.fillStyle="rgba(178,34,34,0.75)";
    pctx.fillText("SUPERCRITICAL", xOfT(300), yOfLP(5.5));
    pctx.restore();

    // Legend
    pctx.save();
    pctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    pctx.fillStyle="#234";
    const lx=pM.l+6, ly=pM.t+14;
    pctx.fillText("Boundaries:", lx, ly);
    // swatches
    const items=[
      {txt:"Sublimation (solid–vapour)", c:"#444"},
      {txt:"Melting (solid–liquid)", c:"#2f8f2f"},
      {txt:"Boiling/condensation (liquid–vapour)", c:"#1e5aa8"},
    ];
    items.forEach((it,i)=>{
      const y=ly+16*(i+1);
      pctx.strokeStyle=it.c; pctx.lineWidth=3;
      pctx.beginPath(); pctx.moveTo(lx, y-4); pctx.lineTo(lx+18, y-4); pctx.stroke();
      pctx.fillText(it.txt, lx+24, y);
    });
    pctx.restore();

    // State point (current)
    const x=xOfT(Tc), y=yOfLP(log10(Pbar));
    pctx.fillStyle="#111";
    pctx.beginPath(); pctx.arc(x,y,6,0,Math.PI*2); pctx.fill();
    pctx.strokeStyle="#fff"; pctx.lineWidth=2;
    pctx.beginPath(); pctx.arc(x,y,6,0,Math.PI*2); pctx.stroke();
  }

  // ---------- Heating curve ----------
  const heatCanvas=document.getElementById("heatCanvas");
  const hctx=heatCanvas.getContext("2d");
  const hW=heatCanvas.width, hH=heatCanvas.height;
  const hM={l:70,r:16,t:18,b:45};

  function drawHeatingCurve(segs, Qnow, Tnow, Tm, Tb, Qmax){
    const Qmin=0, QmaxPlot=Qmax;

    let TminPlot = Math.min(-150, ...segs.map(s=>Math.min(s.T0,s.T1))) - 10;
    let TmaxPlot = Math.max(250, ...segs.map(s=>Math.max(s.T0,s.T1))) + 10;
    TminPlot = clamp(TminPlot, -170, 80);
    TmaxPlot = clamp(TmaxPlot, 120, 470);

    const xOfQ=(Q)=>hM.l + (Q-Qmin)*(hW-hM.l-hM.r)/(QmaxPlot-Qmin);
    const yOfT=(T)=>hH-hM.b - (T-TminPlot)*(hH-hM.t-hM.b)/(TmaxPlot-TminPlot);

    const xTicks=[];
    const tickCount=5;
    for (let i=0;i<=tickCount;i++){
      const q=Qmin + (QmaxPlot-Qmin)*i/tickCount;
      xTicks.push({x:xOfQ(q), label:String(Math.round(q))});
    }
    const yTicks=[];
    for (let T=Math.ceil(TminPlot/100)*100; T<=TmaxPlot; T+=100){
      yTicks.push({y:yOfT(T), label:String(T)});
    }

    drawAxes(hctx,hW,hH,hM,"Heat added Q (kJ)","Temperature (°C)",xTicks,yTicks);

    // curve
    hctx.save();
    hctx.strokeStyle="#111";
    hctx.lineWidth=2.5;
    hctx.beginPath();
    let first=true;
    for (const s of segs){
      const x0=xOfQ(s.Q0), y0=yOfT(s.T0);
      const x1=xOfQ(s.Q1), y1=yOfT(s.T1);
      if (first){hctx.moveTo(x0,y0); first=false;}
      hctx.lineTo(x1,y1);
    }
    hctx.stroke();
    hctx.restore();

    // melt/boil lines
    function hLine(T, label){
      const y=yOfT(T);
      hctx.save();
      hctx.strokeStyle="#b22";
      hctx.setLineDash([6,5]);
      hctx.beginPath(); hctx.moveTo(hM.l,y); hctx.lineTo(hW-hM.r,y); hctx.stroke();
      hctx.setLineDash([]);
      hctx.fillStyle="#234";
      hctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      hctx.fillText(label, hM.l+8, y-6);
      hctx.restore();
    }
    hLine(Tm, "Tm");
    hLine(Tb, "Tb");

    // current point
    const x=xOfQ(Qnow), y=yOfT(Tnow);
    hctx.fillStyle="#1e5aa8";
    hctx.beginPath(); hctx.arc(x,y,6,0,Math.PI*2); hctx.fill();
    hctx.strokeStyle="#fff"; hctx.lineWidth=2;
    hctx.beginPath(); hctx.arc(x,y,6,0,Math.PI*2); hctx.stroke();
  }

  // ---------- UI wiring ----------
  const Pslider=document.getElementById("Pslider");
  const Tstart=document.getElementById("Tstart");
  const mass=document.getElementById("mass");
  const Qslider=document.getElementById("Qslider");

  const Pout=document.getElementById("Pout");
  const logPout=document.getElementById("logPout");
  const TstartOut=document.getElementById("TstartOut");
  const Qout=document.getElementById("Qout");
  const stateOut=document.getElementById("stateOut");
  const TnowOut=document.getElementById("TnowOut");
  const TmOut=document.getElementById("TmOut");
  const TbOut=document.getElementById("TbOut");
  const QmaxLabel=document.getElementById("QmaxLabel");

  function styleButtons(){
    document.querySelectorAll(".btn").forEach(btn=>{
      btn.style.padding="7px 10px";
      btn.style.borderRadius="10px";
      btn.style.border="1px solid #ccd";
      btn.style.background="#fff";
      btn.style.cursor="pointer";
      btn.addEventListener("mouseenter",()=>btn.style.background="#f2f7ff");
      btn.addEventListener("mouseleave",()=>btn.style.background="#fff");
    });
  }

  function updateAll(){
    const logP=parseFloat(Pslider.value);
    const Pbar=Math.pow(10,logP);
    const T0=parseFloat(Tstart.value);
    const mkg=clamp(parseFloat(mass.value||1),0.05,10);

    const {segs, Tm, Tb, Qmax} = buildHeatingSegments(Pbar, T0, mkg);

    // Update Q slider max dynamically
    const QmaxRounded = Math.max(200, Math.ceil(Qmax/50)*50);
    Qslider.max = QmaxRounded;
    QmaxLabel.textContent = `${QmaxRounded} kJ`;

    const Qnow = clamp(parseFloat(Qslider.value), 0, QmaxRounded);
    Qslider.value = Qnow;

    const {T: Tnow, label} = TfromQ(segs, Qnow);
    const ph = phaseOf(Tnow, Pbar);

    Pout.textContent = (Pbar<0.1? Pbar.toExponential(2): (Pbar<1000? Pbar.toFixed(2): Pbar.toExponential(2)));
    logPout.textContent = `log₁₀P = ${logP.toFixed(2)}`;
    TstartOut.textContent = T0.toFixed(0);
    Qout.textContent = Qnow.toFixed(0);
    TnowOut.textContent = Tnow.toFixed(1);

    let stateText = label;
    stateText += ` (${ph})`;
    stateOut.textContent = stateText;

    let col="#0b8a3b";
    if (ph.startsWith("Solid")) col="#555";
    else if (ph==="Vapour") col="#1e5aa8";
    else if (ph.startsWith("Supercritical")) col="#b22";
    stateOut.style.color = col;

    TmOut.textContent = Tm.toFixed(1);
    TbOut.textContent = Tb.toFixed(1);

    drawPhaseDiagram(Tnow, Pbar);
    drawHeatingCurve(segs, Qnow, Tnow, Tm, Tb, Math.min(QmaxRounded, Qmax));
  }

  Pslider.addEventListener("input", updateAll);
  Tstart.addEventListener("input", updateAll);
  mass.addEventListener("input", updateAll);
  Qslider.addEventListener("input", updateAll);

  styleButtons();
  document.querySelectorAll("[data-preset]").forEach(b=>{
    b.addEventListener("click",()=>{
      const p=b.getAttribute("data-preset");
      let Pbar=1.0;
      if (p==="sea") Pbar=1.0;
      if (p==="mountain") Pbar=0.7;
      if (p==="pressurecooker") Pbar=15;
      if (p==="deep") Pbar=1e4;
      if (p==="verydeep") Pbar=1e6;
      Pslider.value = log10(Pbar);
      updateAll();
    });
  });

  updateAll();
})();
</script>